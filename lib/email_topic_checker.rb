require "gds_api/helpers"

class EmailTopicChecker
  include GdsApi::Helpers
  attr_reader :verbose_output, :presented_edition, :edition
  attr_accessor :params

  # The govuk-delivery mongo db stores absolute paths for feed_urls in its
  # db.topics collection. This environment variable lets us swap out the feed
  # urls generated by Whitehall to match the origin host.
  ORIGIN = URI.parse(ENV.fetch("ORIGIN", "https://www.gov.uk"))

  # We make a request to the content store to look up the supertypes for the
  # document as these are used in email-alert-api's SubscriberListQuery. Set
  # this environment variable to skip this check. This is useful if you don't
  # have any data in your local content store and still want the code to run.
  IGNORE_SUPERTYPES = ENV["IGNORE_SUPERTYPES"].present?

  def self.check(document, verbose = true)
    published_edition = document.published_edition
    presented_edition = published_edition &&
      PublishingApiPresenters.presenter_for(published_edition)
    new(presented_edition, published_edition, verbose).check
  end

  def self.check_presented_edition(presented_edition, edition, verbose = true)
    new(presented_edition, verbose).check
  end

  def initialize(presented_edition, edition, verbose = true)
    @edition = edition
    @presented_edition = presented_edition
    @verbose_output = verbose
  end

  def check
    feed_urls = feed_urls(edition)
    govuk_topics = feed_urls.map { |url| govuk_delivery_topic(url) }.compact.sort

    supertypes = content_store_supertypes(presented_edition)
    email_topics = email_alert_api_topics(presented_edition, supertypes)

    additional_govuk = (govuk_topics - email_topics)
    additional_email = (email_topics - govuk_topics)

    if verbose_output
      <<-OUTPUT.strip_heredoc
      email-alert-api params:
      #{params.inspect}

      govuk-delivery feed urls:
      #{feed_urls.join("\n")}

      govuk-delivery topics:
      #{govuk_topics.join("\n")}

      email-alert-api topics:
      #{email_topics.join("\n")}

      additional govuk-delivery topics:
      #{additional_govuk.any? ? additional_govuk.join("\n") : 'None'}

      additional email-alert-api topics:
      #{additional_email.any? ? additional_email.join("\n") : 'None'}
      OUTPUT
    elsif additional_govuk.any?
      presented_edition.content_id
    end
  end

  def govuk_delivery_topic(feed_url)
    feed_uri = URI.parse(feed_url)
    feed_uri.scheme = ORIGIN.scheme
    feed_uri.host = ORIGIN.host

    signup_url = Whitehall.govuk_delivery_client.signup_url(feed_uri.to_s)
    signup_uri = URI.parse(signup_url)
    signup_params = CGI.parse(signup_uri.query)

    signup_params.fetch("topic_id").first
  rescue GdsApi::HTTPNotFound
    nil
  end

  def content_store_supertypes(presented_edition)
    return {} if IGNORE_SUPERTYPES

    base_path = presented_edition.content.to_h.fetch(:base_path)
    content = Whitehall.content_store.content_item(base_path).to_h
    if content["content_id"] != presented_edition.content_id
      raise "content store returned different content item"
    end
    content.slice("email_document_supertype", "government_document_supertype").symbolize_keys
  end

  def email_alert_api_topics(presented_edition, supertypes)
    content = presented_edition.content
    links = presented_edition.links
    details = content[:details]
    tags = details[:tags] if details

    self.params = {
      links: strip_empty_arrays(links || {}),
      tags: strip_empty_arrays(tags || {}),
      document_type: content[:document_type],
    }.merge(supertypes)

    response = email_alert_api.topic_matches(params)
    response.to_h.fetch("topics")
  rescue GdsApi::HTTPNotFound
    nil
  end

  def feed_urls(edition)
    generator = Whitehall::GovUkDelivery::SubscriptionUrlGenerator.new(edition)
    generator.subscription_urls
  end

  def links_hash(feed_url)
    UrlToSubscriberListCriteria.new(feed_url).convert
  end

  def strip_empty_arrays(hash)
    hash.reject { |_, values| values.empty? }
  end
end
